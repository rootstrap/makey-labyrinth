Game = {
  run: function (context, chip, clock, canvasMove, audio) {
    var self = Game;

    self.ctx = context;
    self._previousElapsed = 0;
    self.chip = chip;
    self.start = false;
    self.clock = clock;
    self.canvasMove = canvasMove;
    self.audio = audio;
    var p = self.load();
    Promise.all(p).then(function() {
      Game.init();
      window.requestAnimationFrame(Game.tick)
    }.bind(self));
  },

  tick: function () {
    var self = Game;
    // clear previous frame
    self.ctx.clearRect(0, 0, 624, 688);
    self.render();
    var deadline = new Date(Date.parse(new Date()) + 5 * 1000);
    self.initClock('clockdiv', deadline);
  }.bind(this),

  load: function () {
      return [
          Loader.loadImage('upLeft', "<%= asset_path('curvo1.jpg') %>"),
          Loader.loadImage('downLeft', "<%= asset_path('curvo2.jpg') %>"),
          Loader.loadImage('upRight', "<%= asset_path('curvo3.jpg') %>"),
          Loader.loadImage('downRight', "<%= asset_path('curvo4.jpg') %>"),
          Loader.loadImage('upDown', "<%= asset_path('recti1.jpg') %>"),
          Loader.loadImage('leftRight', "<%= asset_path('recto2.jpg') %>"),
          Loader.loadImage('tiles', "<%= asset_path('solido1.jpg') %>"),
          Loader.loadImage('npc', "<%= asset_path('character.png') %>"),
          Loader.loadImage('v_hole', "<%= asset_path('recti1hole.png') %>"),
          Loader.loadImage('h_hole', "<%= asset_path('recto2hole.png') %>"),
          Loader.loadImage('arrowLeft', "<%= asset_path('left.png') %>"),
          Loader.loadImage('arrowRight', "<%= asset_path('right.png') %>"),
          Loader.loadImage('arrowUp', "<%= asset_path('up.png') %>"),
          Loader.loadImage('arrowDown', "<%= asset_path('down.png') %>"),
          Loader.loadImage('arrowJump', "<%= asset_path('jump.png') %>"),
      ];
  },


  init: function () {
      var self = Game;

      self.solid = Loader.getImage('tiles');
      self.upLeft = Loader.getImage('upLeft');
      self.downLeft = Loader.getImage('downLeft');
      self.upRight = Loader.getImage('upRight');
      self.downRight = Loader.getImage('downRight');
      self.upDown = Loader.getImage('upDown');
      self.leftRight = Loader.getImage('leftRight');
      self.arrowLeft = Loader.getImage('arrowLeft');
      self.arrowRight = Loader.getImage('arrowRight');
      self.arrowUp = Loader.getImage('arrowUp');
      self.arrowDown = Loader.getImage('arrowDown');
      self.arrowJump = Loader.getImage('arrowJump');
      self.h = Loader.getImage('h_hole');
      self.v = Loader.getImage('v_hole');
      self.npc = Loader.getImage('npc');


      self.chip.style.transition = 'none';
      if (tile_index == 0){
        self.posX = 0;
        self.posY = 8;
        self.winPosX = 3;
        self.winPosY = 0;
        self.chip.style.left = '0px';

      } else if (tile_index == 1){
        self.posX = 0;
        self.posY = 8;
        self.winPosX=4;
        self.winPosY=0;
        self.chip.style.left = '0px';
      } else if (tile_index == 2){
        self.posX = 3;
        self.posY = 8;
        self.winPosX=4;
        self.winPosY=0;
        self.chip.style.left = '234px';
      } else if(tile_index == 3){
        self.posX = 7;
        self.posY = 8;
        self.winPosX=5;
        self.winPosY=0;
        self.chip.style.left = '546px';
      }

      self.canvasX = 0;
      self.canvasY = 0;
      self.countDraw = 0;
      self.firstTime = true;
      self.canSetMovement = true;

      self.chip.style.bottom = '-' + TILE_SIZE + 'px';

      self.timeout = TIMEOUT;

  },

  render: function () {
    var self = Game;
    for (var c = 0; c < map.cols; c++) {
      for (var r = 0; r < map.rows; r++) {
        var tile = map.getTileAux(c,r);

          if(tile == 1){
            console.log(self);
            self.ctx.drawImage(self.solid, c * map.tsize, r * map.tsize);
          }
          if(tile == 2){
            self.ctx.drawImage(self.downRight, c * map.tsize, r * map.tsize);
          }
          if(tile == 3){
            self.ctx.drawImage(self.leftRight, c * map.tsize, r * map.tsize);
          }
          if(tile == 4) {
            self.ctx.drawImage(self.upRight, c * map.tsize, r * map.tsize);
          }
          if(tile == 5) {
            self.ctx.drawImage(self.upDown, c * map.tsize, r * map.tsize);
          }
          if(tile == 6) {
            self.ctx.drawImage(self.downLeft, c * map.tsize, r * map.tsize);
          }
          if(tile == 7) {
            self.ctx.drawImage(self.upLeft, c * map.tsize, r * map.tsize);
          }
          if(tile == 8){
            self.ctx.drawImage(self.h, c * map.tsize, r * map.tsize);
          }
          if(tile == 9){
            self.ctx.drawImage(self.v, c * map.tsize, r * map.tsize);
          }
      }
    }

    self._drawGrid();
  },

  _drawGrid: function () {
      var self = Game;

      var width = map.cols * map.tsize;
      var height = map.rows * map.tsize;

      var x, y;
      for (var r = 0; r < map.rows; r++) {
          y = r * map.tsize;
          x = 0
          self.ctx.beginPath();
          self.ctx.moveTo(x, y);
          self.ctx.lineTo(width, y);
          self.ctx.strokeStyle = '#ffffff'
          self.ctx.stroke();
      }
      for (var c = 0; c < map.cols; c++) {
          x = c * map.tsize;
          y = 0
          self.ctx.beginPath();
          self.ctx.moveTo(x, y);
          self.ctx.lineTo(x, height);
          self.ctx.strokeStyle = '#ffffff'
          self.ctx.stroke();
      }

  },

  moveChip: function (num, bounce, jump, in_hole, timeout, cont, lastMovement, nextMovement) {
   var self = Game;

   setTimeout(function() {
      var movement = movements.getMovement(num);

      if (!bounce && !jump && !in_hole){

        switch(movement){
          case 'u':
            if (map.getTileAux(Game.posX, Game.posY-1) !== 1 && validMovement('u', Game.posX, Game.posY) &&
                !(isAPit(Game.posX, Game.posY-1))){

                self.chip.style.bottom = parseInt(self.chip.style.bottom) + TILE_SIZE + 'px';
                Game.posY -= 1;
            }else if (movement == 'u' && !(isAPit(Game.posX, Game.posY-1))) {
                moveUp();
                cont++;
                bounce = true;

            }  else if(isAPit(Game.posX, Game.posY-1)){

                self.chip.style.bottom = parseInt(self.chip.style.bottom) + TILE_SIZE + 'px';
                Game.posY -= 1;
                in_hole = true;
            }
            break;
          case 'd':
            if (map.getTileAux(Game.posX , Game.posY+1) !== 1 && validMovement('d', Game.posX, Game.posY)
                && !isAPit(Game.posX , Game.posY+1)){
                self.chip.style.bottom = parseInt(self.chip.style.bottom) - TILE_SIZE + 'px';
                Game.posY += 1
            } else if(movement == 'd' && !isAPit(Game.posX , Game.posY+1)) {
                moveDown();
                cont++;
                bounce = true;
            }else if(isAPit(Game.posX , Game.posY+1)){
                self.chip.style.bottom = parseInt(self.chip.style.bottom) - TILE_SIZE + 'px';
                Game.posY += 1
                in_hole = true;
            }
            break;
          case 'r':

            if (map.getTileAux(Game.posX+1, Game.posY) !== 1 && validMovement('r', Game.posX, Game.posY)
                && !isAPit(Game.posX+1, Game.posY)) {
                self.chip.style.left = parseInt(self.chip.style.left) + TILE_SIZE + 'px';
                Game.posX += 1

            } else if( !isAPit(Game.posX+1, Game.posY) && movement == 'r') {
                moveRight();
                cont++;
                bounce = true;

            } else if(isAPit(Game.posX+1, Game.posY)) {

                self.chip.style.left = parseInt(self.chip.style.left) + TILE_SIZE + 'px';
                Game.posX += 1
                in_hole = true;

            }
            break;
          case 'l':
            if(map.getTileAux(Game.posX - 1 , Game.posY) !== 1 && validMovement('l', Game.posX, Game.posY)
                && !isAPit(Game.posX - 1 , Game.posY)){
              self.chip.style.left = parseInt(self.chip.style.left) - TILE_SIZE + 'px';
              Game.posX -= 1
            } else if(movement == 'l' && !isAPit(Game.posX - 1 , Game.posY)) {
              moveLeft();
              cont++;
              bounce = true;
            }else if(isAPit(Game.posX - 1 , Game.posY)){
              self.chip.style.left = parseInt(self.chip.style.left) - TILE_SIZE + 'px';
              Game.posX -= 1;
              in_hole = true;
            }
            break;
          case 'j':
            jump = true;
            switch(lastMovement){
              case 'start':
                if (isHoleUp(9,12,13)){
                  self.chip.style.bottom = parseInt(self.chip.style.bottom) + TILE_SIZE + 'px';
                  Game.posY -= 1;
                  addJumpEffect();
                  if (map.getTileAux(Game.posX, Game.posY-1) !== 1 && validMovement('u', Game.posX, Game.posY)){
                    nextMovement = 'u';
                  } else if (map.getTileAux(Game.posX-1, Game.posY) !== 1 && validMovement('l', Game.posX, Game.posY)){
                    nextMovement = 'l';
                  } else if (map.getTileAux(Game.posX+1, Game.posY) !== 1 && validMovement('r', Game.posX, Game.posY)){
                    nextMovement = 'r';
                  }
                } else {
                  addJumpEffect();
                  nextMovement = 'none';
                }
                break;
              case 'u':
                if (map.getTileAux(Game.posX, Game.posY) == 5){
                  nextMovement = jumpUp()
                } else if (map.getTileAux(Game.posX, Game.posY) == 2){
                  nextMovement = jumpRight()
                } else if (map.getTileAux(Game.posX, Game.posY) == 6){
                  nextMovement = jumpLeft()
                }
                break;
              case 'd':
                if (map.getTileAux(Game.posX, Game.posY) == 5){
                  nextMovement = jumpUp()
                } else if (map.getTileAux(Game.posX, Game.posY) == 2){
                  nextMovement = jumpRight()
                } else if (map.getTileAux(Game.posX, Game.posY) == 6){
                  nextMovement = jumpLeft()
                }
                break;
              case 'l':
                if (map.getTileAux(Game.posX, Game.posY) == 3){
                  nextMovement = jumpLeft()
                } else if (map.getTileAux(Game.posX, Game.posY) == 2){
                  nextMovement = jumpDown()
                } else if (map.getTileAux(Game.posX, Game.posY) == 7){
                  nextMovement = jumpUp()
                }
                break;
              case 'r':
                if (map.getTileAux(Game.posX, Game.posY) == 3){
                  nextMovement = jumpRight()
                } else if (map.getTileAux(Game.posX, Game.posY) == 4){
                  nextMovement = jumpUp()
                } else if (map.getTileAux(Game.posX, Game.posY) == 6){
                  nextMovement = jumpDown()
                }
                break;
              case 'j':
                addJumpEffect();
                nextMovement = 'none';
              break;
            }
            break;
        }
        if (!bounce){
          lastMovement = movement;
        }
      } else if (bounce) {
        switch(movement){
          case 'u':
            values = bounceUp(cont, bounce);
            cont = values[0];
            bounce = values[1];
            break;
          case 'd':
            values = bounceDown(cont, bounce);
            cont = values[0];
            bounce = values[1];
            break;
          case 'l':
            values = bounceLeft(cont, bounce);
            cont = values[0];
            bounce = values[1];
            break;
          case 'r':
            values = bounceRight(cont, bounce);
            cont = values[0];
            bounce = values[1];
            break;
        }
      } else if (jump) {
        jump = false;
        switch(nextMovement){
          case 'u':
            self.chip.style.bottom = parseInt(self.chip.style.bottom) + TILE_SIZE + 'px';
            Game.posY -= 1;
            break;
          case 'd':
            self.chip.style.bottom = parseInt(self.chip.style.bottom) - TILE_SIZE + 'px';
            Game.posY += 1;
            break;
          case 'l':
            self.chip.style.left = parseInt(self.chip.style.left) - TILE_SIZE + 'px';
            Game.posX -= 1;
            break;
          case 'r':
            self.chip.style.left = parseInt(self.chip.style.left) + TILE_SIZE + 'px';
            Game.posX += 1;
            break;
          default:
            console.log(nextMovement, 'entre aca');
            break;
        }
        removeJumpEffect();
      } else if (in_hole) {
        self.chip.style.transform = 'scale(0.5) rotate(360deg)';

        lose = true
      }
      if(lose || (num == movements.allMovements.length) ){
        loseOrWin();
      } else if (in_hole){
        Game.moveChip(num, bounce, jump, in_hole, TIMEOUT, cont, lastMovement, nextMovement)
      } else if (bounce){

        Game.moveChip(num, bounce, jump, in_hole, 250, cont, lastMovement, nextMovement);
      } else if (jump) {

        Game.moveChip(num, bounce, jump, in_hole, TIMEOUT, cont, lastMovement, nextMovement);
      } else if (num < movements.allMovements.length){

        Game.moveChip(num+1, bounce, jump, in_hole, TIMEOUT, cont, lastMovement, nextMovement);
      } else if (in_hole){
        Game.moveChip(num, bounce, jump, in_hole, TIMEOUT, cont, lastMovement, nextMovement)
      }
    }, timeout);
  },


  handleKeypress: function(event) {
    var self = Game;

    if(Game.canSetMovement){
      if(Game.countDraw == 5){
        Game.canvasX = 0;
        Game.canvasY += 60;
        Game.countDraw = 0;
      }
      else if(Game.countDraw < 5 && !Game.firstTime){
        Game.canvasX += 60;
      }
      else if(Game.firstTime){
        Game.canvasX = 0;
      }

    switch(event.keyCode) {
          case 32: {
              Game.canvasMove.drawImage(Game.arrowJump, Game.canvasX, Game.canvasY);
              Game.countDraw++;
              Game.firstTime = false;
              allMovements.push('j');
              break;
          }
          case 37: {
              Game.canvasMove.drawImage(Game.arrowLeft, Game.canvasX, Game.canvasY);
              Game.countDraw++;
              Game.firstTime = false;
              allMovements.push('l');
              break;
          }
          case 38: {
              Game.canvasMove.drawImage(Game.arrowUp, Game.canvasX, Game.canvasY);
              Game.countDraw++;
              Game.firstTime = false;
              allMovements.push('u');
              break;
          }
          case 39: {
              Game.canvasMove.drawImage(Game.arrowRight, Game.canvasX, Game.canvasY);
              Game.countDraw++;
              Game.firstTime = false;
              allMovements.push('r');
              break;
          }
          case 40: {
              Game.canvasMove.drawImage(Game.arrowDown, Game.canvasX, Game.canvasY);
              Game.countDraw++;
              Game.firstTime = false;
              allMovements.push('d');
              break;
          }
          default: {
              //not a key we care about
              break;
          }
        }
      }
  },

  initClock: function (id, endtime) {
    var self = Game;

    var clock = Game.clock;
    var secondsSpan = Game.clock.querySelector('.clock-seconds-title');

    function updateClock() {
      var t = getTimeRemaining(endtime);
      secondsSpan.innerHTML = ('0' + t.seconds).slice(-2);

      if (t.total <= 0) {
        clearInterval(timeinterval);
        Game.canSetMovement = false;

        swal({ title: "A jugar!", text: "A ver si tienes suerte",
               timer: 2000, showConfirmButton: false });

        setTimeout(function() {
          hideMovements();

          Game.audio.volume = 0.5;
          Game.audio.play();

          self.chip.style.transition = 'all 1s ease';
          Game.moveChip(0, false, false, false, TIMEOUT, 0, 'start', 'none');

        }, 2500);
      }
    }

    updateClock();
    var timeinterval = setInterval(updateClock, 1000);
  }

}
